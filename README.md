## 프로젝트 개요

실제 프로젝트를 진행하면서 필요(있으면 편)한 기능들을 만듦

DI와 오브젝트 풀링 기법을 사용해 new / delete를 최소화함.
또한 스마트 포인터를 직접 구현해 현재 만든 DI와 연동해 Release같은 따로 함수 호출이 없어도 DIContainer에 객체 반환하기.

## 구조 설계
DIContainer로 객체를 가져올 때 그 객체는 Dependency_ptr<T>라는 이름의 클래스이다.
이 클래스는 Dependency_Inner_ptr<T>*라는 변수와 여러가지 연산자를 오버로딩해 재정의한 함수를 가짐.
- ->연산 : T의 주소로 이동함.
- =연산 : nullptr을 넣은 경우, Dependency_Inner_ptr<T>*에 저장된 참조값을 1 감소시킴.
- *연산 : 일반적인 스마트 포인터처럼 내부 객체(T)에 대한 참조를 반환하지 않는다.
    대신 Dependency_ptr<T> 객체를 복사해 반환하며, 이때 참조 카운트가 1 증가한다.

Dependency_Inner_ptr<T>
이 클래스는 T의 포인터를 직접적으로 저장하는 클래스임.
참조카운트를 가지고 있음.


## 사용법
### 프로젝트에 적용하는 법
1. 이 레포지토리의 서브모듈 브랜치로 이동한다.
2. 서브모듈 브랜치를 서브모듈 혹은 일반 클론해서 받아온다.
3. 클론한 브랜치를 프로젝트에 합친 후, Dependency.h라는 파일을 include해준다.

### 프로젝트에서 사용하는 법
1. 우선 사용할 클래스를 만든다.
   - 사용할 클래스는 IDependency를 상속받는 객체이어야 한다.
   - IDependency는 Reset이라는 함수를 가지는 인터페이스이다.
   - 생성자는 무조건 ContsructorParam&을 인자로 가져야한다. 
2. 사용할 객체를 DIContainer에 등록한다. **DIContainer::Bind<Interface, Implementation>()함수 사용**
   - 등록하기 위해서는 두가지의 클래스가 필요하다.
     - 첫번째 클래스는 IDependency를 상속받는 Interface. 함수 선언만하는 인터페이스이다.
     - 두번째 클래스는 Interface를 상속받아 Interface의 함수를 구현하는 구현체이다.
3. 객체를 받아온다. **DIContainer::GetInstance<Interface>(ConstructorParam& param)**
   - 이 함수는 Bind함수를 통해 등록한 객체를 생성한다.
   - 이 함수 반환타입은 Dependency_ptr<Interface>이다.
     -  반환타입이 저런 이유는 직접 정의한 포인터를 바탕으로 참조카운트를 세주기 때문이다.
   - ConstructorParam 구조체는 받아오려는 클래스의 생성자를 이용해 객체를 생성할 때 필요한 데이터를 담는 데이터 구조체이다.
     - 복사 비용을 줄이기 위해 참조자 사용

4. 객체 사용하기
   - *연산자를 자기 자신을 복사하고 내부의 참조 카운트를 1 증가 시킴.
      이것은 GetInstance로 받아온 객체를 다른 클래스에서 사용 할 일이 생긴 경우, 무조건 *연산을 통해 받아온 객체를 사용해야함.
   - =연산을 통해 nullptr값을 넣어준 경우, 참조카운트를 1 감소 시킨 후, 내부 포인터를 nullptr로 만들어 사용이 불가하게 만들음.
   - 또한 스코프로 객체가 수거되었을 경우, 참조 카운트를 1 감소시킨다. nullptr을 대입한 경우는 참조 카운트를 감소시키지 않는다.
   - 참조 카운트가 0이 되었을 경우 **DIContainer::ReturnInstance<T>(T* instance)**을 실행해 객체를 반환시켜준다.
  
## 주의점
  1. Depenedency_ptr은 무조건 복사 타입으로만 사용해야함.
   &연산을 통해 주소를 불러와 사용하는 것은 금지함.
   설계에 어긋나 버그가 일어날 수 있기 때문임.
  2. Dependency_ptr혹은 Dependency_Inner_ptr은 무조건 DIContainer에서만 생성이 되어야 한다.
     new를 이용해 생성하는 것은 허용하지 않는다.

## 단점
1. 템플릿을 사용해서 컴파일 시간이 길어질 수 있음.
   - 템플릿은 메타프로그래밍 언어 도구이기 때문에 런타임에 타입을 지정하지 않고,  컴파일 단계에 직접 코드를 생성하기 때문에, 프로젝트의 크기가 방대해질 수록, 컴파일 시간이 늘어남

## 어려웠던 점
템플릿 함수나 클래스는 정의를 모두 헤더에서 해야 했기 때문에 정의를 모두 헤더에서 해주었는데,
Dependency_ptr과 DIContainer간에 include 순환 참조 문제가 발생했다.

템플릿 함수나 클래는 전방 선언을 해도, 사용할 함수나 클래스가 정의 되어있지 않다면 컴파일 단계에서 오류가 나기 때문에 이 문제는 무조건 해결 해야했다.

이 문제를 해결하기 위해서 템플릿 함수를 헤더에서 정의하지 않고, 선언만해준다.

inl파일을 만들어 헤더 파일에서 선언한 함수를 정의해준다.
헤더파일의 끝에 inl파일을 include해준다.

이렇게 템플릿 함수의 선언과 정의를 분리해 문제를 해결했다.
# 감사합니다.
